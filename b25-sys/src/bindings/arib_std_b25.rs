/* automatically generated by rust-bindgen 0.59.2 */

#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![warn(dead_code)]

use std::marker::PhantomPinned;

pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 31;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __LONG_DOUBLE_USES_FLOAT128: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const __TIMESIZE: u32 = 64;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const _O_BINARY: u32 = 0;
pub const _O_SEQUENTIAL: u32 = 0;
pub const _BYTESWAP_H: u32 = 1;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__fsid_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct B_CAS_INIT_STATUS {
    pub system_key: [u8; 32usize],
    pub init_cbc: [u8; 8usize],
    pub bcas_card_id: i64,
    pub card_status: i32,
    pub ca_system_id: i32,
}
#[test]
fn bindgen_test_layout_B_CAS_INIT_STATUS() {
    assert_eq!(
        ::std::mem::size_of::<B_CAS_INIT_STATUS>(),
        56usize,
        concat!("Size of: ", stringify!(B_CAS_INIT_STATUS))
    );
    assert_eq!(
        ::std::mem::align_of::<B_CAS_INIT_STATUS>(),
        8usize,
        concat!("Alignment of ", stringify!(B_CAS_INIT_STATUS))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<B_CAS_INIT_STATUS>())).system_key as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(B_CAS_INIT_STATUS),
            "::",
            stringify!(system_key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<B_CAS_INIT_STATUS>())).init_cbc as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(B_CAS_INIT_STATUS),
            "::",
            stringify!(init_cbc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<B_CAS_INIT_STATUS>())).bcas_card_id as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(B_CAS_INIT_STATUS),
            "::",
            stringify!(bcas_card_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<B_CAS_INIT_STATUS>())).card_status as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(B_CAS_INIT_STATUS),
            "::",
            stringify!(card_status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<B_CAS_INIT_STATUS>())).ca_system_id as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(B_CAS_INIT_STATUS),
            "::",
            stringify!(ca_system_id)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct B_CAS_ID {
    pub data: *mut i64,
    pub count: i32,
}
#[test]
fn bindgen_test_layout_B_CAS_ID() {
    assert_eq!(
        ::std::mem::size_of::<B_CAS_ID>(),
        16usize,
        concat!("Size of: ", stringify!(B_CAS_ID))
    );
    assert_eq!(
        ::std::mem::align_of::<B_CAS_ID>(),
        8usize,
        concat!("Alignment of ", stringify!(B_CAS_ID))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<B_CAS_ID>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(B_CAS_ID),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<B_CAS_ID>())).count as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(B_CAS_ID),
            "::",
            stringify!(count)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct B_CAS_PWR_ON_CTRL {
    pub s_yy: i32,
    pub s_mm: i32,
    pub s_dd: i32,
    pub l_yy: i32,
    pub l_mm: i32,
    pub l_dd: i32,
    pub hold_time: i32,
    pub broadcaster_group_id: i32,
    pub network_id: i32,
    pub transport_id: i32,
}
#[test]
fn bindgen_test_layout_B_CAS_PWR_ON_CTRL() {
    assert_eq!(
        ::std::mem::size_of::<B_CAS_PWR_ON_CTRL>(),
        40usize,
        concat!("Size of: ", stringify!(B_CAS_PWR_ON_CTRL))
    );
    assert_eq!(
        ::std::mem::align_of::<B_CAS_PWR_ON_CTRL>(),
        4usize,
        concat!("Alignment of ", stringify!(B_CAS_PWR_ON_CTRL))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<B_CAS_PWR_ON_CTRL>())).s_yy as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(B_CAS_PWR_ON_CTRL),
            "::",
            stringify!(s_yy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<B_CAS_PWR_ON_CTRL>())).s_mm as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(B_CAS_PWR_ON_CTRL),
            "::",
            stringify!(s_mm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<B_CAS_PWR_ON_CTRL>())).s_dd as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(B_CAS_PWR_ON_CTRL),
            "::",
            stringify!(s_dd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<B_CAS_PWR_ON_CTRL>())).l_yy as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(B_CAS_PWR_ON_CTRL),
            "::",
            stringify!(l_yy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<B_CAS_PWR_ON_CTRL>())).l_mm as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(B_CAS_PWR_ON_CTRL),
            "::",
            stringify!(l_mm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<B_CAS_PWR_ON_CTRL>())).l_dd as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(B_CAS_PWR_ON_CTRL),
            "::",
            stringify!(l_dd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<B_CAS_PWR_ON_CTRL>())).hold_time as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(B_CAS_PWR_ON_CTRL),
            "::",
            stringify!(hold_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<B_CAS_PWR_ON_CTRL>())).broadcaster_group_id as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(B_CAS_PWR_ON_CTRL),
            "::",
            stringify!(broadcaster_group_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<B_CAS_PWR_ON_CTRL>())).network_id as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(B_CAS_PWR_ON_CTRL),
            "::",
            stringify!(network_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<B_CAS_PWR_ON_CTRL>())).transport_id as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(B_CAS_PWR_ON_CTRL),
            "::",
            stringify!(transport_id)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct B_CAS_PWR_ON_CTRL_INFO {
    pub data: *mut B_CAS_PWR_ON_CTRL,
    pub count: i32,
}
#[test]
fn bindgen_test_layout_B_CAS_PWR_ON_CTRL_INFO() {
    assert_eq!(
        ::std::mem::size_of::<B_CAS_PWR_ON_CTRL_INFO>(),
        16usize,
        concat!("Size of: ", stringify!(B_CAS_PWR_ON_CTRL_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<B_CAS_PWR_ON_CTRL_INFO>(),
        8usize,
        concat!("Alignment of ", stringify!(B_CAS_PWR_ON_CTRL_INFO))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<B_CAS_PWR_ON_CTRL_INFO>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(B_CAS_PWR_ON_CTRL_INFO),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<B_CAS_PWR_ON_CTRL_INFO>())).count as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(B_CAS_PWR_ON_CTRL_INFO),
            "::",
            stringify!(count)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct B_CAS_ECM_RESULT {
    pub scramble_key: [u8; 16usize],
    pub return_code: u32,
}
#[test]
fn bindgen_test_layout_B_CAS_ECM_RESULT() {
    assert_eq!(
        ::std::mem::size_of::<B_CAS_ECM_RESULT>(),
        20usize,
        concat!("Size of: ", stringify!(B_CAS_ECM_RESULT))
    );
    assert_eq!(
        ::std::mem::align_of::<B_CAS_ECM_RESULT>(),
        4usize,
        concat!("Alignment of ", stringify!(B_CAS_ECM_RESULT))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<B_CAS_ECM_RESULT>())).scramble_key as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(B_CAS_ECM_RESULT),
            "::",
            stringify!(scramble_key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<B_CAS_ECM_RESULT>())).return_code as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(B_CAS_ECM_RESULT),
            "::",
            stringify!(return_code)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct B_CAS_CARD {
    pub private_data: *mut ::std::os::raw::c_void,
    pub release: ::std::option::Option<unsafe extern "C" fn(bcas: *mut ::std::os::raw::c_void)>,
    pub init: ::std::option::Option<
        unsafe extern "C" fn(bcas: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
    pub get_init_status: ::std::option::Option<
        unsafe extern "C" fn(
            bcas: *mut ::std::os::raw::c_void,
            stat: *mut B_CAS_INIT_STATUS,
        ) -> ::std::os::raw::c_int,
    >,
    pub get_id: ::std::option::Option<
        unsafe extern "C" fn(
            bcas: *mut ::std::os::raw::c_void,
            dst: *mut B_CAS_ID,
        ) -> ::std::os::raw::c_int,
    >,
    pub get_pwr_on_ctrl: ::std::option::Option<
        unsafe extern "C" fn(
            bcas: *mut ::std::os::raw::c_void,
            dst: *mut B_CAS_PWR_ON_CTRL_INFO,
        ) -> ::std::os::raw::c_int,
    >,
    pub proc_ecm: ::std::option::Option<
        unsafe extern "C" fn(
            bcas: *mut ::std::os::raw::c_void,
            dst: *mut B_CAS_ECM_RESULT,
            src: *mut u8,
            len: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub proc_emm: ::std::option::Option<
        unsafe extern "C" fn(
            bcas: *mut ::std::os::raw::c_void,
            src: *mut u8,
            len: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_B_CAS_CARD() {
    assert_eq!(
        ::std::mem::size_of::<B_CAS_CARD>(),
        64usize,
        concat!("Size of: ", stringify!(B_CAS_CARD))
    );
    assert_eq!(
        ::std::mem::align_of::<B_CAS_CARD>(),
        8usize,
        concat!("Alignment of ", stringify!(B_CAS_CARD))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<B_CAS_CARD>())).private_data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(B_CAS_CARD),
            "::",
            stringify!(private_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<B_CAS_CARD>())).release as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(B_CAS_CARD),
            "::",
            stringify!(release)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<B_CAS_CARD>())).init as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(B_CAS_CARD),
            "::",
            stringify!(init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<B_CAS_CARD>())).get_init_status as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(B_CAS_CARD),
            "::",
            stringify!(get_init_status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<B_CAS_CARD>())).get_id as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(B_CAS_CARD),
            "::",
            stringify!(get_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<B_CAS_CARD>())).get_pwr_on_ctrl as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(B_CAS_CARD),
            "::",
            stringify!(get_pwr_on_ctrl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<B_CAS_CARD>())).proc_ecm as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(B_CAS_CARD),
            "::",
            stringify!(proc_ecm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<B_CAS_CARD>())).proc_emm as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(B_CAS_CARD),
            "::",
            stringify!(proc_emm)
        )
    );
}
extern "C" {
    pub fn create_b_cas_card() -> *mut B_CAS_CARD;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ARIB_STD_B25_BUFFER {
    pub data: *mut u8,
    pub size: u32,
}
#[test]
fn bindgen_test_layout_ARIB_STD_B25_BUFFER() {
    assert_eq!(
        ::std::mem::size_of::<ARIB_STD_B25_BUFFER>(),
        16usize,
        concat!("Size of: ", stringify!(ARIB_STD_B25_BUFFER))
    );
    assert_eq!(
        ::std::mem::align_of::<ARIB_STD_B25_BUFFER>(),
        8usize,
        concat!("Alignment of ", stringify!(ARIB_STD_B25_BUFFER))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ARIB_STD_B25_BUFFER>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ARIB_STD_B25_BUFFER),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ARIB_STD_B25_BUFFER>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ARIB_STD_B25_BUFFER),
            "::",
            stringify!(size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ARIB_STD_B25_PROGRAM_INFO {
    pub program_number: i32,
    pub ecm_unpurchased_count: i32,
    pub last_ecm_error_code: i32,
    pub padding: i32,
    pub total_packet_count: i64,
    pub undecrypted_packet_count: i64,
}
#[test]
fn bindgen_test_layout_ARIB_STD_B25_PROGRAM_INFO() {
    assert_eq!(
        ::std::mem::size_of::<ARIB_STD_B25_PROGRAM_INFO>(),
        32usize,
        concat!("Size of: ", stringify!(ARIB_STD_B25_PROGRAM_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<ARIB_STD_B25_PROGRAM_INFO>(),
        8usize,
        concat!("Alignment of ", stringify!(ARIB_STD_B25_PROGRAM_INFO))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ARIB_STD_B25_PROGRAM_INFO>())).program_number as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ARIB_STD_B25_PROGRAM_INFO),
            "::",
            stringify!(program_number)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ARIB_STD_B25_PROGRAM_INFO>())).ecm_unpurchased_count as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ARIB_STD_B25_PROGRAM_INFO),
            "::",
            stringify!(ecm_unpurchased_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ARIB_STD_B25_PROGRAM_INFO>())).last_ecm_error_code as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ARIB_STD_B25_PROGRAM_INFO),
            "::",
            stringify!(last_ecm_error_code)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ARIB_STD_B25_PROGRAM_INFO>())).padding as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ARIB_STD_B25_PROGRAM_INFO),
            "::",
            stringify!(padding)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ARIB_STD_B25_PROGRAM_INFO>())).total_packet_count as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ARIB_STD_B25_PROGRAM_INFO),
            "::",
            stringify!(total_packet_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ARIB_STD_B25_PROGRAM_INFO>())).undecrypted_packet_count
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ARIB_STD_B25_PROGRAM_INFO),
            "::",
            stringify!(undecrypted_packet_count)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ARIB_STD_B25 {
    private_data: *mut ::std::os::raw::c_void,
    release: ::std::option::Option<unsafe extern "C" fn(std_b25: *mut ::std::os::raw::c_void)>,
    set_multi2_round: ::std::option::Option<
        unsafe extern "C" fn(
            std_b25: *mut ::std::os::raw::c_void,
            round: i32,
        ) -> ::std::os::raw::c_int,
    >,
    set_strip: ::std::option::Option<
        unsafe extern "C" fn(
            std_b25: *mut ::std::os::raw::c_void,
            strip: i32,
        ) -> ::std::os::raw::c_int,
    >,
    set_emm_proc: ::std::option::Option<
        unsafe extern "C" fn(
            std_b25: *mut ::std::os::raw::c_void,
            on: i32,
        ) -> ::std::os::raw::c_int,
    >,
    set_simd_mode: ::std::option::Option<
        unsafe extern "C" fn(
            std_b25: *mut ::std::os::raw::c_void,
            instructin: i32,
        ) -> ::std::os::raw::c_int,
    >,
    get_simd_mode:
        ::std::option::Option<unsafe extern "C" fn(std_b25: *mut ::std::os::raw::c_void) -> i32>,
    set_b_cas_card: ::std::option::Option<
        unsafe extern "C" fn(
            std_b25: *mut ::std::os::raw::c_void,
            bcas: *mut B_CAS_CARD,
        ) -> ::std::os::raw::c_int,
    >,
    set_unit_size: ::std::option::Option<
        unsafe extern "C" fn(
            std_b25: *mut ::std::os::raw::c_void,
            size: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    reset: ::std::option::Option<
        unsafe extern "C" fn(std_b25: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
    flush: ::std::option::Option<
        unsafe extern "C" fn(std_b25: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
    put: ::std::option::Option<
        unsafe extern "C" fn(
            std_b25: *mut ::std::os::raw::c_void,
            buf: *mut ARIB_STD_B25_BUFFER,
        ) -> ::std::os::raw::c_int,
    >,
    get: ::std::option::Option<
        unsafe extern "C" fn(
            std_b25: *mut ::std::os::raw::c_void,
            buf: *mut ARIB_STD_B25_BUFFER,
        ) -> ::std::os::raw::c_int,
    >,
    get_program_count: ::std::option::Option<
        unsafe extern "C" fn(std_b25: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
    get_program_info: ::std::option::Option<
        unsafe extern "C" fn(
            std_b25: *mut ::std::os::raw::c_void,
            info: *mut ARIB_STD_B25_PROGRAM_INFO,
            idx: i32,
        ) -> ::std::os::raw::c_int,
    >,
    withdraw: ::std::option::Option<
        unsafe extern "C" fn(
            std_b25: *mut ::std::os::raw::c_void,
            buf: *mut ARIB_STD_B25_BUFFER,
        ) -> ::std::os::raw::c_int,
    >,
    _pin_marker: PhantomPinned,
}
impl ARIB_STD_B25 {
    pub fn release(&mut self) {
        unsafe {
            if !self.release.is_none() {
                self.release.unwrap()(self as *mut _ as *mut ::std::os::raw::c_void);
            }
        }
    }
    pub fn set_multi2_round(&self, round: i32) -> ::std::os::raw::c_int {
        unsafe {
            match self.set_multi2_round {
                Some(f) => f(self as *const _ as *mut ::std::os::raw::c_void, round),
                None => unreachable!("Maybe uninitialized"),
            }
        }
    }
    pub fn set_strip(&self, strip: i32) -> ::std::os::raw::c_int {
        unsafe {
            match self.set_strip {
                Some(f) => f(self as *const _ as *mut ::std::os::raw::c_void, strip),
                None => unreachable!("Maybe uninitialized"),
            }
        }
    }
    pub fn set_emm_proc(&self, on: i32) -> ::std::os::raw::c_int {
        unsafe {
            match self.set_emm_proc {
                Some(f) => f(self as *const _ as *mut ::std::os::raw::c_void, on),
                None => unreachable!("Maybe uninitialized"),
            }
        }
    }
    pub fn set_simd_mode(&self, instruction_type: i32) -> ::std::os::raw::c_int {
        unsafe {
            match self.set_simd_mode {
                Some(f) => f(
                    self as *const _ as *mut ::std::os::raw::c_void,
                    instruction_type,
                ),
                None => unreachable!("Maybe uninitialized"),
            }
        }
    }
    pub fn get_simd_mode(&self) -> i32 {
        unsafe {
            match self.get_simd_mode {
                Some(f) => f(self as *const _ as *mut ::std::os::raw::c_void),
                None => unreachable!("Maybe uninitialized"),
            }
        }
    }
    pub fn set_b_cas_card(&self, bcas: &mut B_CAS_CARD) -> ::std::os::raw::c_int {
        unsafe {
            match self.set_b_cas_card {
                Some(f) => f(
                    self as *const _ as *mut ::std::os::raw::c_void,
                    bcas as *mut _,
                ),
                None => unreachable!("Maybe uninitialized"),
            }
        }
    }
    pub fn set_unit_size(&self, size: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        unsafe {
            match self.set_unit_size {
                Some(f) => f(self as *const _ as *mut ::std::os::raw::c_void, size),
                None => unreachable!("Maybe uninitialized"),
            }
        }
    }
    pub fn reset(&self) -> ::std::os::raw::c_int {
        unsafe {
            match self.reset {
                Some(f) => f(self as *const _ as *mut ::std::os::raw::c_void),
                None => unreachable!("Maybe uninitialized"),
            }
        }
    }
    pub fn flush(&self) -> ::std::os::raw::c_int {
        unsafe {
            match self.flush {
                Some(f) => f(self as *const _ as *mut ::std::os::raw::c_void),
                None => unreachable!("Maybe uninitialized"),
            }
        }
    }
    pub fn put(&self, buf: &ARIB_STD_B25_BUFFER) -> ::std::os::raw::c_int {
        unsafe {
            match self.put {
                Some(f) => f(
                    self as *const _ as *mut ::std::os::raw::c_void,
                    buf as *const _ as *mut _,
                ),
                None => unreachable!("Maybe uninitialized"),
            }
        }
    }
    pub fn get(&self, buf: &mut ARIB_STD_B25_BUFFER) -> ::std::os::raw::c_int {
        unsafe {
            match self.get {
                Some(f) => f(
                    self as *const _ as *mut ::std::os::raw::c_void,
                    buf as *mut _,
                ),
                None => unreachable!("Maybe uninitialized"),
            }
        }
    }
    pub fn get_program_count(&self) -> i32 {
        unsafe {
            match self.get_program_count {
                Some(f) => f(self as *const _ as *mut ::std::os::raw::c_void),
                None => unreachable!("Maybe uninitialized"),
            }
        }
    }
    pub fn get_program_info(&self, info: &mut ARIB_STD_B25_PROGRAM_INFO, idx: i32) -> i32 {
        unsafe {
            match self.get_program_info {
                Some(f) => f(
                    self as *const _ as *mut ::std::os::raw::c_void,
                    info as *mut _,
                    idx,
                ),
                None => unreachable!("Maybe uninitialized"),
            }
        }
    }
    pub fn withdraw(&self, buf: &mut ARIB_STD_B25_BUFFER) -> i32 {
        unsafe {
            match self.withdraw {
                Some(f) => f(
                    self as *const _ as *mut ::std::os::raw::c_void,
                    buf as *mut _,
                ),
                None => unreachable!("Maybe uninitialized"),
            }
        }
    }
}
#[test]
fn bindgen_test_layout_ARIB_STD_B25() {
    assert_eq!(
        ::std::mem::size_of::<ARIB_STD_B25>(),
        128usize,
        concat!("Size of: ", stringify!(ARIB_STD_B25))
    );
    assert_eq!(
        ::std::mem::align_of::<ARIB_STD_B25>(),
        8usize,
        concat!("Alignment of ", stringify!(ARIB_STD_B25))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ARIB_STD_B25>())).private_data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ARIB_STD_B25),
            "::",
            stringify!(private_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ARIB_STD_B25>())).release as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ARIB_STD_B25),
            "::",
            stringify!(release)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ARIB_STD_B25>())).set_multi2_round as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ARIB_STD_B25),
            "::",
            stringify!(set_multi2_round)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ARIB_STD_B25>())).set_strip as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ARIB_STD_B25),
            "::",
            stringify!(set_strip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ARIB_STD_B25>())).set_emm_proc as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ARIB_STD_B25),
            "::",
            stringify!(set_emm_proc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ARIB_STD_B25>())).set_simd_mode as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ARIB_STD_B25),
            "::",
            stringify!(set_simd_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ARIB_STD_B25>())).get_simd_mode as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ARIB_STD_B25),
            "::",
            stringify!(get_simd_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ARIB_STD_B25>())).set_b_cas_card as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ARIB_STD_B25),
            "::",
            stringify!(set_b_cas_card)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ARIB_STD_B25>())).set_unit_size as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ARIB_STD_B25),
            "::",
            stringify!(set_unit_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ARIB_STD_B25>())).reset as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ARIB_STD_B25),
            "::",
            stringify!(reset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ARIB_STD_B25>())).flush as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(ARIB_STD_B25),
            "::",
            stringify!(flush)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ARIB_STD_B25>())).put as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(ARIB_STD_B25),
            "::",
            stringify!(put)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ARIB_STD_B25>())).get as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(ARIB_STD_B25),
            "::",
            stringify!(get)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ARIB_STD_B25>())).get_program_count as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(ARIB_STD_B25),
            "::",
            stringify!(get_program_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ARIB_STD_B25>())).get_program_info as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(ARIB_STD_B25),
            "::",
            stringify!(get_program_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ARIB_STD_B25>())).withdraw as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(ARIB_STD_B25),
            "::",
            stringify!(withdraw)
        )
    );
}
extern "C" {
    pub fn create_arib_std_b25() -> *mut ARIB_STD_B25;
}

pub type wchar_t = ::std::os::raw::c_int;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct B_CAS_CARD_PRIVATE_DATA {
    pub mng: ::std::os::raw::c_long,
    pub card: ::std::os::raw::c_long,
    pub pool: *mut u8,
    pub reader: *const wchar_t,
    pub sbuf: *mut u8,
    pub rbuf: *mut u8,
    pub stat: B_CAS_INIT_STATUS,
    pub id: B_CAS_ID,
    pub id_max: i32,
    pub pwc: B_CAS_PWR_ON_CTRL_INFO,
    pub pwc_max: i32,
}
#[test]
fn bindgen_test_layout_B_CAS_CARD_PRIVATE_DATA() {
    assert_eq!(
        ::std::mem::size_of::<B_CAS_CARD_PRIVATE_DATA>(),
        152usize,
        concat!("Size of: ", stringify!(B_CAS_CARD_PRIVATE_DATA))
    );
    assert_eq!(
        ::std::mem::align_of::<B_CAS_CARD_PRIVATE_DATA>(),
        8usize,
        concat!("Alignment of ", stringify!(B_CAS_CARD_PRIVATE_DATA))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<B_CAS_CARD_PRIVATE_DATA>())).mng as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(B_CAS_CARD_PRIVATE_DATA),
            "::",
            stringify!(mng)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<B_CAS_CARD_PRIVATE_DATA>())).card as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(B_CAS_CARD_PRIVATE_DATA),
            "::",
            stringify!(card)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<B_CAS_CARD_PRIVATE_DATA>())).pool as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(B_CAS_CARD_PRIVATE_DATA),
            "::",
            stringify!(pool)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<B_CAS_CARD_PRIVATE_DATA>())).reader as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(B_CAS_CARD_PRIVATE_DATA),
            "::",
            stringify!(reader)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<B_CAS_CARD_PRIVATE_DATA>())).sbuf as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(B_CAS_CARD_PRIVATE_DATA),
            "::",
            stringify!(sbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<B_CAS_CARD_PRIVATE_DATA>())).rbuf as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(B_CAS_CARD_PRIVATE_DATA),
            "::",
            stringify!(rbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<B_CAS_CARD_PRIVATE_DATA>())).stat as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(B_CAS_CARD_PRIVATE_DATA),
            "::",
            stringify!(stat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<B_CAS_CARD_PRIVATE_DATA>())).id as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(B_CAS_CARD_PRIVATE_DATA),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<B_CAS_CARD_PRIVATE_DATA>())).id_max as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(B_CAS_CARD_PRIVATE_DATA),
            "::",
            stringify!(id_max)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<B_CAS_CARD_PRIVATE_DATA>())).pwc as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(B_CAS_CARD_PRIVATE_DATA),
            "::",
            stringify!(pwc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<B_CAS_CARD_PRIVATE_DATA>())).pwc_max as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(B_CAS_CARD_PRIVATE_DATA),
            "::",
            stringify!(pwc_max)
        )
    );
}
